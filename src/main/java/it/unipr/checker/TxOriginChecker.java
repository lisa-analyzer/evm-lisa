package it.unipr.checker;

import it.unipr.analysis.EVMAbstractState;
import it.unipr.analysis.MyCache;
import it.unipr.cfg.EVMCFG;
import it.unipr.cfg.Origin;
import it.unipr.cfg.ProgramCounterLocation;
import it.unive.lisa.analysis.SimpleAbstractState;
import it.unive.lisa.analysis.heap.MonolithicHeap;
import it.unive.lisa.analysis.nonrelational.value.TypeEnvironment;
import it.unive.lisa.analysis.types.InferredTypes;
import it.unive.lisa.checks.semantic.CheckToolWithAnalysisResults;
import it.unive.lisa.checks.semantic.SemanticCheck;
import it.unive.lisa.program.cfg.CFG;
import it.unive.lisa.program.cfg.statement.Statement;
import java.util.Set;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

public class TxOriginChecker implements
		SemanticCheck<SimpleAbstractState<MonolithicHeap, EVMAbstractState, TypeEnvironment<InferredTypes>>> {

	private static final Logger log = LogManager.getLogger(TxOriginChecker.class);

	@Override
	public boolean visit(
			CheckToolWithAnalysisResults<
					SimpleAbstractState<MonolithicHeap, EVMAbstractState, TypeEnvironment<InferredTypes>>> tool,
			CFG graph, Statement node) {

		if (node instanceof Origin) {
			EVMCFG cfg = ((EVMCFG) graph);
			Set<Statement> jumps = cfg.getAllJumps();
			Statement origin = node;

			for (Statement jump : jumps) {
				if (cfg.reachableFrom(origin, jump)) {
					ProgramCounterLocation jumploc = (ProgramCounterLocation) jump.getLocation();

					log.debug("Tx. Origin attack at {} at line no. {} coming from line {}", jumploc.getPc(),
							jumploc.getSourceCodeLine(),
							((ProgramCounterLocation) origin.getLocation()).getSourceCodeLine());

					String warn = "TxOrigin attack at " + jumploc.getPc();
					tool.warn(warn);
					MyCache.getInstance().addTxOriginWarning(cfg.hashCode(), warn);
					break;

					// The first draft of the code is to check if a jump is
					// reachable starting from an origin opcode, but it is not
					// always true that
					// the vulnerability is generated by that jump
					// TODO taint analysis, looking for the jump that uses a
					// contaminated value from the stack by origin opcode
					// (GENERICS)
				}
			}

		}

		return true;
	}
}