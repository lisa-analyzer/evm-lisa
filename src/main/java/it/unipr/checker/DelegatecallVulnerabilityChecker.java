package it.unipr.checker;
import it.unipr.analysis.EVMAbstractState;
import it.unipr.cfg.Delegatecall;
import it.unipr.cfg.EVMCFG;
import it.unive.lisa.analysis.AnalysisState;
import it.unive.lisa.analysis.AnalyzedCFG;
import it.unive.lisa.analysis.SemanticException;
import it.unive.lisa.analysis.SimpleAbstractState;
import it.unive.lisa.analysis.heap.MonolithicHeap;
import it.unive.lisa.analysis.nonrelational.value.TypeEnvironment;
import it.unive.lisa.analysis.types.InferredTypes;
import it.unive.lisa.checks.semantic.CheckToolWithAnalysisResults;
import it.unive.lisa.checks.semantic.SemanticCheck;
import it.unive.lisa.program.cfg.CFG;
import it.unive.lisa.program.cfg.statement.Statement;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

/**
 * Semantic checker wich detect a possible exploit through the delegatecall opcode.
 * It detects if the contract beign called by the delegatecall is stateless or not
 */
public class DelegatecallVulnerabilityChecker implements
        SemanticCheck<SimpleAbstractState<MonolithicHeap, EVMAbstractState, TypeEnvironment<InferredTypes>>> {
    private static final Logger log = LogManager.getLogger(DelegatecallVulnerabilityChecker.class);

    private static boolean isEnabled = false;

    public static void enableChecker() {
        isEnabled = true;
    }

    public static void disableChecker() {
        isEnabled = false;
    }

    public static boolean isEnabled() {
        return isEnabled;
    }
    @Override
    public boolean visit(CheckToolWithAnalysisResults<
                                     SimpleAbstractState<MonolithicHeap, EVMAbstractState, TypeEnvironment<InferredTypes>>> tool,
                         CFG graph, Statement node){

        if(node instanceof Delegatecall){
            EVMCFG cfg = ((EVMCFG) graph);
            Statement delegatecall = node; // Renaming

            for (AnalyzedCFG<SimpleAbstractState<MonolithicHeap, EVMAbstractState,
                                TypeEnvironment<InferredTypes>>> result : tool.getResultOf(cfg)) {
                AnalysisState<SimpleAbstractState<MonolithicHeap, EVMAbstractState,
                                        TypeEnvironment<InferredTypes>>> analysisResult = null;

                try {
                    analysisResult = result.getAnalysisStateBefore(delegatecall);
                } catch (SemanticException e) {
                    log.error("Error in DelegatecallChecker: ", e);
                }

                //TODO: check if the contract is stateless or not
            }
        }

        return true;
    }
    
}
