pragma solidity ^0.8.10;
// SPDX-License-Identifier: MIT

/**
 * WARNING: This contract contains intentional security vulnerabilities for testing purposes
 */
contract UnsafeDelegateCallContract {
    // Storage variables that could be vulnerable to storage collision attacks
    address public owner;
    uint256 public counter;
    mapping(address => uint256) public balances;
    bool public paused;
    // Address of the contract to delegate call
    address public contractAddress;
    // Address of the contract to delegate call in the fallback
    address public libraryAddress;
    // Flag to indicate if the contract has been initialized
    bool public initialized;



    // Events for logging actions
    event DelegateCallExecuted(address targetContract, bytes data, bool success);
    event FundsDeposited(address depositor, uint256 amount);
    event FundsWithdrawn(address recipient, uint256 amount);
    event OwnershipTransferred(address previousOwner, address newOwner);
    event FallbackCalled(bytes data);

    // Constructor to set only initial owner
    constructor()  public{
        owner = msg.sender;
    }

    function initialize(address _libraryAddress, address _contractAddress) external {
        require(!initialized, "Already initialized");
        libraryAddress = _libraryAddress;
        contractAddress = _contractAddress;
        initialized = true;
    }

    // Unsafe modifier without proper checks
    modifier onlyOwner() {
        // Vulnerable: Using == instead of require()
        if (msg.sender == owner) {
            _;
        }
    }

    // Vulnerable receive function that updates state
    receive() external payable {
        balances[msg.sender] += msg.value;
        emit FundsDeposited(msg.sender, msg.value);
    }

    /**
     * @dev Executes delegatecall to the provided target address with the given data
     * @param _target Address of the contract to delegate call to
     * @param _data The calldata to be passed to the target contract
     * @return success Whether the delegatecall was successful
     * @return result The raw result data from the delegatecall
     */
    function unsafeDelegateCall(address _target, bytes memory _data)
        public
        returns (bool success, bytes memory result)
    {
        // Vulnerable: No input validation for target address
        // Vulnerable: No restrictions on who can call this function

        // Vulnerable: Raw delegatecall without checking return status properly
        (success, result) = _target.delegatecall(_data);

        // Emit event regardless of success
        emit DelegateCallExecuted(_target, _data, success);

        return (success, result);
    }

    /**
     * @dev Another delegate call function with slightly different implementation but same vulnerabilities
     * @param _targetContract Address of the contract to delegate call to
     * @param _calldata The calldata to be passed to the target contract
     */
    function executeDelegateCall(address _targetContract, bytes calldata _calldata)
        external
        onlyOwner
        returns (bool)
    {
        // Vulnerable: No validation on target contract
        // Vulnerable: Using low-level call with delegatecall opcode
        (bool success, ) = _targetContract.delegatecall(_calldata);

        // Increment counter to record call attempt
        counter++;

        return success;
    }

    /**
     * @dev Function to deposit funds into the contract
     */
    function deposit() external payable {
        // Vulnerable: No checks for overflow
        balances[msg.sender] += msg.value;
        emit FundsDeposited(msg.sender, msg.value);
    }

    /**
     * @dev Function to withdraw funds from the contract
     * @param _amount Amount to withdraw
     */
    function withdraw(uint256 _amount) external {
        // Vulnerable: Sends funds before updating state (reentrancy)
        require(balances[msg.sender] >= _amount, "Insufficient funds");

        // Vulnerable: Using call without value check
        (bool success, ) = msg.sender.call{value: _amount}("");
        require(success, "Transfer failed");

        balances[msg.sender] -= _amount;
        emit FundsWithdrawn(msg.sender, _amount);
    }

    /**
     * @dev Function to transfer ownership of the contract
     * @param _newOwner Address of the new owner
     */
    function transferOwnership(address _newOwner) external onlyOwner {
        // Vulnerable: No validation for a null address
        emit OwnershipTransferred(owner, _newOwner);
        owner = _newOwner;
    }
    function setPaused(bool _paused) external onlyOwner {
        paused = _paused;
    }
    // Example of function that could be used to exploit contracts using delegatecall
    // This function is a danger for OTHER contract, this isn't a vulnerability of the contract itself
    function setOwner(address _newOwner) external {
        // This function is dangerous if called via delegatecall
        owner = _newOwner;
    }

    function setContractAAddress(address _address) public {
         contractAddress = _address;
    }

    function delegateCallToContractA(uint256 _data) public {
        // Perform delegate call to Contract A's setData function
        // Vulnerable: No checks on the target contract address
        (bool success, ) = contractAddress.delegatecall(abi.encodeWithSignature("setData(uint256)", _data));
        require(success, "Delegate call failed");
    }
    function setLibraryAddress(address _address) external onlyOwner {
        libraryAddress = _address;
    }

    fallback () external payable {
        emit FallbackCalled(msg.data);
        require(libraryAddress != address(0), "Library address not set");

        (bool success,) = libraryAddress.delegatecall(msg.data);

    }
}